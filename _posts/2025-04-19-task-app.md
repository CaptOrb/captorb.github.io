## Lessons from building a task management application

### Objective
I wanted to build a full-stack task management application to get hands-on experience with various modern tools and frameworks. Additionally, I wanted to take a concept from the **planning stage** all the way to deployment. This included:
- **Conceptualising the app's features and architecture**
- **Choosing the right tools for frontend, backend, database, and deployment**
- **Building, testing, and deploying the app**

### Programming languages/ Frameworks / Tools used
- **Backend**: Java, SpringBoot, REST API
- **Frontend**: React + Tailwind CSS
- **Database**: MySQL
- **Containerisation**: Docker
- **Deployment**: Github Actions
- **Automated Testing**: JUnit and Mockitio



## Experience building the app
Building this task management application introduced me to a variety of new challenges and learning opportunities.

For the backend, One of the biggest hurdles was working Spring Security. I quickly discovered that Spring Security keeps rapidly evolving, with deprecations and removal of methods between versions and the documentation isn't always up-to-date or easy to follow. That said, Spring Security was still useful as it allowed me to implemement robust authentication and authorisation mechanisms.

I chose Hibernate as the ORM to handle database interactions. I was pleasantly surprised by how powerful and easy it was to integrate with SpringBoot, allowing for smooth CRUD operations without writing SQL queries manually. For handling authentication, I used JWT tokens. This allowed me to implement stateless authentication, with every user getting a JWT token assigned to them upon login and having their token expire after a set time period.

On the frontend side, this was my first time working with React, and I found state management to be a challenge initially but overall, I enjoyed using React and found the documentation to be helpful. 
React’s single-page approach is different from traditional server-side frameworks like Flask and Thymeleaf that I would of been more familar with conceptually. Tradiitonally with frameworks like Flask, the server handles rendering most of the content, whereas in a React SPA, the frontend is responsible for much more of the user interaction and rendering. This shift required me to dive deep into managing routes, components, and state updates within React. I additionally used Tailwind CSS for styling the webpages, it was my first time using Tailwind CSS. but I found it very easy to use.

I had to grapple with CORS (Cross-Origin Resource Sharing). A brief explanation of CORS might be in order. Modern browsers enforces a concept called the "Same Origin Policy (SOP)" for security reasons. The Same Origin Policy prevents a website’s JavaScript from making requests to a different address (origin) than the site's address. 
Without SOP, a malicious site could potentically send requests to your bank using your active session. It could transfer money from your account without your consent. The SOP prevents this by blocking cross-origin requests.

As my backend and frontend were hosted on different domains, I had to configure CORS in the backend to allow the frontend to communicate to the backend without being blocked by CORS. So, the backend and frontend are running on different domains (and ports), how does the frontend talk to the backend? The answer is through a REST API.

## Deployment
This section is a work in progress.
CI/CD
nginx
cross compile

## Deployed URL.
[[TaskApp](https://taskapp.librepush.net)]


## Future Enhancements.
- Add OAuth integration
- Refresh the JWT tokens upon expiry.

## Conclusion
This section is a work in progress.



